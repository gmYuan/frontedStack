


webpakc执行流程

## 一 总体调用栈部分

```js
// 命令行--> webpack-cli/bin/cli.js 下
1. 命令行执行 webpack/ npm run build -->
  2.1 const webpack = require('webpack')
  2.2 const compiler = webpack(config) -->
    // 3 node_modules/webpack/lib/webpack.js
  2.3 compiler.run();


// webpack/lib/webpack.js内
2.2 webpack() -->
  3.1 const compiler = createCompiler() -->
    4.1 new Compiler()
    4.2 applyWebpackOptionsDefaults();
    4.3 new WebpackOptionsApply().process() -->
      5.1 new EntryOptionPlugin().apply(): 注册了entryOption 钩子
      5.2 compiler.hooks.entryOption.call(): 立即触发entryOption 钩子
        6.1 new EntryPlugin().apply(): 监听2个钩子

      5.3 new FlagDependencyExportsPlugin().apply()
      5.4 new FlagDependencyUsagePlugin().apply()
      5.5 ... 更多内置插件


2.3 compiler.run() -->
  7.1 触发一些 compiler钩子
    8.1 compiler.compile() -->
      9.1 compilation = compiler.newCompilation()

      9.2 hooks.make.callAsync() -->
        10.1 hooks.finishMake.callAsync()
        10.2 compilation.finish()
        10.3 compilation.seal() -->
        10.4 hooks.afterCompile.callAsync()


9.1 compiler.newCompilation()



```


## 二 关键函数解析

### 2.2 webpack()

功能：创建 compiler → 返回 compiler

```js
const webpack = (options, callback) => {
  const compiler = createCompiler(options);
  return compiler;
}
```


### 3.1 createCompiler()

功能：
  - new Compiler(): 创建编译器
  - options.plugin.apply(): 注册 用户插件
  - applyWebpackOptionsDefaults(): 设置 默认配置
  - WebpackOptionsApply().process(): 注册 内置插件

```js
const createCompiler = rawOptions => {
  // 1. 创建 Compiler 对象
  const compiler = new Compiler(options.context);
  compiler.options = options;

  // 2. 应用用户配置的插件
  if (Array.isArray(options.plugins)) {
    for (const plugin of options.plugins) {
      plugin.apply(compiler);
    }
  }

  // 3. 设置默认配置
  applyWebpackOptionsDefaults(options);

  // 4. 注册 内置插件
  new WebpackOptionsApply().process(options, compiler);
}
```


###  4.1 new Compiler()

功能：
  - 继承自 Tapable类
  - 定义了 各种类型的 自定义事件钩子Hook
  - 定义了 属性 和 执行流程相关的 方法

```js
class Compiler extends Tapable {
  constructor(context) {
    super();
    // 1. 初始化各种钩子
    this.hooks = {
      // 环境相关

      // 编译相关
      // .....
      run: new AsyncSeriesHook(["compiler"]),
      compile: new SyncHook(["params"]),
      make: new AsyncParallelHook(["compilation"]),

      // .....
      // 输出相关
      emit: new AsyncSeriesHook(["compilation"]),
      done: new AsyncSeriesHook(["stats"]),
      // ...更多钩子
    };

    // 2. 初始化基础属性
    this.context = context; // 项目根目录
    this.options = {}; // 配置项
    
    // 3. 初始化各种缓存和存储
    // ...更多属性
    this._compilations = new Set(); // 编译缓存
    this.records = {}; // 记录

    // 4. 核心方法
    // ...更多方法
    run(callback) {},
    compile(callback) {},
    emitAssets(compilation, callback) {},
  }
}
```


### 4.3 new WebpackOptionsApply().process()

功能：
  - 注册 入口插件
  - 注册 Tree Shaking 相关插件
  - 注册 其他功能性插件

```js
class WebpackOptionsApply {
  process(options, compiler) {
    // 1. 应用入口插件
    new EntryOptionPlugin().apply(compiler);
    compiler.hooks.entryOption.call(options.context, options.entry);

    // 2. 根据配置应用对应的内置插件
    if (options.optimization.providedExports) {
      // 收集模块导出信息的插件
      new FlagDependencyExportsPlugin().apply(compiler);
    }
    
    if (options.optimization.usedExports) {
      // 分析导出使用情况的插件
      new FlagDependencyUsagePlugin().apply(compiler);
    }

    // ... 应用更多内置插件
  }
}
```

### 5.1 new EntryOptionPlugin().apply()

功能：注册了 compiler.hooks.entryOption 钩子

```js
class EntryOptionPlugin {
  apply(compiler) {
    compiler.hooks.entryOption.tap("EntryOptionPlugin", (context, entry) => {
      // 在这里创建 EntryPlugin 实例
      new EntryPlugin(context, entry, 'main').apply(compiler);
    });
  }
}
```

### 6.1 new EntryPlugin().apply()

功能：
  - 监听 compiler.hooks.thisCompilation钩子
  - 监听 compiler.hooks.make钩子

```js
class EntryPlugin {
  constructor(context, entry, name) {}

  apply(compiler) {
    // 1. 监听 thisCompilation 钩子
    compiler.hooks.thisCompilation.tap();
    // 2. 监听 make 钩子
    compiler.hooks.make.tapAsync();
  }
}
```


### 2.3 compiler.run()

功能：
  - hooks.beforeRun → hooks.run：准备编译环境 + 清理缓存
  - 触发一些 compiler钩子
  - compiler.compile(): 开始编译流程
  - newCompilation(): 创建新的 compilation 实例
  - hooks.make(): 从入口文件开始构建，收集依赖关系
  - hooks.finishMake(): 完成构建 + 处理模块间的依赖关系
  - compilation.seal(): 生成和优化 chunks + 生成代码
  

```js
class Compiler {
  run(callback) {
    // 1. 触发 beforeRun 钩子
    this.hooks.beforeRun.callAsync(this, err => {
      // 2. 触发 run 钩子
      this.hooks.run.callAsync(this, err => {
        // 3. 读取记录
        this.readRecords(err => {
          // 4. 开始编译
          this.compile(onCompiled)
        });
      });
    });
  }

  compile(callback) {
     // 创建编译参数
    const params = this.newCompilationParams()

    // ...
    // 触发 beforeCompile 钩子
    this.hooks.beforeCompile.callAsync(params)

    // 触发 compile 钩子
   this.hooks.compile.call(params);

    //  创建 compilation 对象
    const compilation = this.newCompilation(params);

    // 触发 make 钩子，开始构建
    this.hooks.make.callAsync(compilation, err => {
      // ....
      this.hooks.finishMake.callAsync() -->
        compilation.finish() -->
           compilation.seal() -->
             this.hooks.afterCompile.callAsync()   
    }
  }
}
```


### 8.1 compiler.newCompilation()

功能：
  - 


```js
// Compiler.js

newCompilation(params) {
 // 创建新的 compilation 实例
  const compilation = new Compilation(this)

  // ...基础属性设置

  // 触发 thisCompilation 钩子
  this.hooks.thisCompilation.call(compilation, params);



}

```