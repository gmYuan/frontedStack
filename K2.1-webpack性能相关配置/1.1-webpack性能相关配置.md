Q1.1 为什么要有 sourceMap, 它有什么作用

A: <br/>

1 sourceMap 是一种表示映射关系的 文件，它可以将编译后的代码映射回源码，方便调试

2 sourceMap 的 大致实现原理
 - 只记录关键位置（如每行开始、变量名等）
 - 用相对位置减少数据量
 - 通过特殊编码压缩数据
 - 建立索引加快查找

具体可参考 [JavaScript Source Map 详解](https://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html)

-----------------------------------------------------------------------------
Q1.2 如何配置 sourceMap

A: <br/>

1 sourceMap 的 基础类型
  - `eval`: 使用 eval 包裹模块代码
  - `cheap`: 不包含列信息(仅限行)
  - `source-map`: 包含行和列信息，生成一个独立的 sourcemap 文件
  - `inline`: 将 sourcemap 作为 DataUrl 嵌入到文件中
  - `module`: 包含 loader 的 sourcemap
  - `hidden`: 生成但不在文件中引用 sourcemap

2 devtool 的 配置值：以上 sourceMap 基础类型的 组合

3 开发环境 推荐使用 `eval-(cheap)-source-map`，原因是:
  - 使用 eval 执行模块，重建速度较快
  - 包含行信息，方便调试

4 生产环境 推荐使用 `hidden-source-map`，原因是:
  - 生成一个独立的 sourcemap 文件，方便部署
  - 隐藏源码信息，避免泄露
  - 可以把 sourcemap 上传到错误监控系统


-----------------------------------------------------------------------------
Q2.1 为什么要进行 打包分离，它有什么作用 + 有几种打包分离的类型 + 注意事项

A: <br/>

1 打包分离 的 作用
 - 减小单个文件体积，提高首屏加载速度
 - 利用浏览器缓存机制，提高再访问速度
 - 按需加载，减少不必要的资源加载

2 常见打包分离的 类型/方法
  -  入口分离（entry points）：手动设置多个入口
  -  动态导入（dynamic imports）：使用 import() 或 require.ensure 按需加载
  -  代码分割（code splitting）：使用 SplitChunksPlugin 插件
    - 分离 第三方库/基础库(node_modules)
    - 分离 公共模块 (common chunks)
    - 分离 异步模块 (async chunks)

3 注意事项
  - 需要合理设置分包大小
  - 保持 chunk 数量适中，避免过度分割==> 分包太小可能导致请求数过多; 分包太大可能影响首屏加载
  - 生成的 chunk 名称最好稳定，从而便于缓存


-------------------------------------------------------------------------------
Q2.2 如何实现 基础库分离

A: <br/>

1 方法1: 使用 CDN + html-webpack-externals-plugin 插件
  - 使用 CDN 引入第三方库，避免打包到 bundle 中
  - 使用 html-webpack-externals-plugin 插件，将第三方库从 bundle 中分离

```js
// webpack.config.js
const config = {
  // ... 其他配置
  plugins: [
    // module: 指定要外部化的 第三方库名称
    // entry:  指定 第三方库的 cdn 地址;
    //         插件会自动把这个链接注入到 HTML 的 <script> 标签中
    // global: 指定 第三方库暴露的 window.xxx 全局变量名
    new HtmlWebpackExternalsPlugin({
      externals: [
        {
          module: 'react',
          entry: 'https://xxx.url.cn/now/lib/16.2.0/react.min.js',
          global: 'React',
        },
        {
          module: 'react-dom',
          entry: 'https://xxx.url.cn/now/lib/16.2.0/react-dom.min.js',
          global: 'ReactDOM',
        },
      ],
    }),
  ],
};
```

2 方法2: 使用 SplitChunksPlugin 插件，单独打包 第三方库/基础库

```js
// webpack.config.js
module.exports = {
  // ... 其他配置
  optimization: {
    splitChunks: {
      cacheGroups: {
        commons: {
          test: /(react|react-dom)/,
          name: 'vendors',
          chunks: 'all',
      },
      },
    },
  };
};  
```

注意，方法1和方法2的区别
  - 加载方式不同：方法1 完全从打包产物中分离；方法2 仍然是webpack打包产物的一部分，只是被分离到单独的chunk文件中
  - 缓存策略不同：方法1 利用 CDN 的缓存，可以跨站点共享缓存了；方法2 利用浏览器对静态资源的缓存，仅限当前站点
  - 部署和控制：方法1 依赖外部 CDN 服务，版本更新需要修改 CDN 地址；方法2 完全自主可控，版本更新只需要重新打包

综上：
  - 方法1 适合大型稳定的第三方库，如 react/vue 等
  - 方法2 适合 业务相关的第三方库，如 工具库/组件库 等


-----------------------------------------------------------------------------
Q2.3 列出 SplitChunksPlugin 插件的 常见配置项，它还能有什么作用

A: <br/>

1 常见配置项

```js
module.exports = {
  optimization: {
    splitChunks: {
      // 1. 基础配置
      // 用于配置哪些类型的 chunks 内部需要 被再次分割; 值分别为 异步/同步/全部
      chunks: 'async', 
      // 想分割的 chunk 最小体积（bytes），小于该值则不分割
      minSize: 20000,      
      // 想分割的 chunk 最大体积（bytes），大于该值则尝试 分割成更小的部分
      maxSize: 0,          
      // 模块被引用的最小次数，大于该值才分割
      minChunks: 1,        
      // 异步加载时的 最大并行请求数
      maxAsyncRequests: 30,   
      // 入口点/首次加载的 最大并行请求数
      maxInitialRequests: 30,  
      // 强制执行分割的体积阈值，忽略其他限制
      enforceSizeThreshold: 50000,  

      // 2. 自动命名
      // 分割chunk名称的连接符
      automaticNameDelimiter: '~', 
      // chunk的名称，true表示自动生成

      // 3. 缓存组配置
      cacheGroups: {
        vendors: {
          // 匹配规则，决定哪些模块 会被分到这个cacheGroup中
          test: /[\\/]node_modules[\\/]/,  
          // 优先级，当一个模块同时符合多个缓存组时，选择优先级高的
          priority: -10,    
          // 是否复用 已有的chunk
          reuseExistingChunk: true,  
          // 分割后的chunk名称
          name: 'vendors',  
          // name 是 chunk 的内部标识，filename 是 最终输出的文件名规则
          // 如果没有设置 filename，webpack 会用 name 来生成文件名
          filename: '[name].bundle.js',  
        },
      }
    }
  }
};
```

2 其他作用==> 可以利用 splitChunks 插件，实现 分离页面的公共文件

```js
module.exports = {
  optimization: {
    splitChunks: {  
      minSize: 0,
      // 通过只设置 使用模块被引用的最小次数 来 分离页面的 公共文件
      cacheGroups: {
        commons: {
          name: 'commons',
          chunks: 'all',
          minChunks: 2,
        }
      }
    }
  }
}
```