Q1.1 为什么要有 HtmlWebpackPlugin 插件, 它有什么作用

A: <br/>

1. 自动化:
  - 自动生成 HTML文件 + 自动引入打包后的 JS文件==> 减少手动维护的工作

2. 一致性:
  - 确保 HTML 文件始终引用最新的打包后的资源，避免手动维护的错误

3. 灵活性: 允许配置 HTML 模板，满足不同项目需求
  - 可以配置自定义的 HTML模板 和 模板参数
  - 支持多页面应用: 可以生成多个 HTML 文件

4. 优化: 可以配置压缩 HTML，提高加载性能   


------------------------------------------------------------------
Q1.2 如何使用和配置 HtmlWebpackPlugin 插件

A: <br/>

1. 创建 自定义模板:
  - 创建一个 HTML 模板文件，例如 `src/index.html`

2. 安装 HtmlWebpackPlugin:

```bash
yarn add html-webpack-plugin -D
```

3. 在 webpack.config.js 中配置:

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  // ... 其他配置
  plugins: [
    new HtmlWebpackPlugin({
      // 指定 模板文件路径
      template: './src/index.html', 
      // 输出的 HTML 文件名
      filename: 'index.html',                    
      // HTML 压缩配置
      minify: {                      
        removeComments: true,
        // 去除空行
        collapseWhitespace: true
      },
      // 添加hash
      hash: true
    })
  ]
};
```

4. 多页面应用配置:

```javascript
plugins: [
  new HtmlWebpackPlugin({
    template: './src/index.html',
    filename: 'index.html',
    chunks: ['main']
  }),
  new HtmlWebpackPlugin({
    template: './src/about.html',
    filename: 'about.html',
    chunks: ['about']
  })
]
```


------------------------------------------------------------------
Q1.3 如何实现 自动动态配置 多页面应用(MPA) 打包

A: <br/>

1 方法1: 手动配置 HtmlWebpackPlugin==> 每次新增或删除⻚⾯需要改 webpack 配置

2 方法2: 使用 glob 模块 读取 页面路径, 动态生成 HtmlWebpackPlugin 插件

```js
const glob = require('glob');
const path = require('path');

const setMPA = () => {
  const entry = {};
  const htmlWebpackPlugins = [];
  // S1 使用 glob.sync 读取 页面路径：前提是需要遵循默认规范: src/[dirName]/index.js 为各页面入口文件
  // entryFiles是一个数组，包含所有匹配该模式的文件的完整路径，如 ['/src/dirName/index.js']
  const entryFiles = glob.sync(path.join(__dirname, './src/*/index.js'));

  Object.keys(entryFiles).map((index) => {
    // S2.1 获取 页面入口文件的路径，如 '/Users/xxx/my-project/src/[dirName]/index.js'
    const entryFile = entryFiles[index];
    
    // S2.2通过正则，获取 dirName 页面名称
    const match = entryFile.match(/src\/(.*)\/index\.js/);
    const pageName = match && match[1];

    // S2.3 把 页面名称 作为 key，页面入口文件路径 作为 value，存入 entry 对象中
    entry[pageName] = entryFile;

    // S3 生成多个 HtmlWebpackPlugin 实例
    htmlWebpackPlugins.push(
      new HtmlWebpackPlugin({
        inlineSource: '.css$',
        template: path.join(__dirname, `src/${pageName}/index.html`),
        filename: `${pageName}.html`,
        chunks: ['vendors', pageName],
        inject: true,
        minify: {
          html5: true,
          collapseWhitespace: true,
          preserveLineBreaks: false,
          minifyCSS: true,
          minifyJS: true,
          removeComments: false
        }
      })
    );
  });

  return {
    entry,
    htmlWebpackPlugins
  }
}

const { entry, htmlWebpackPlugins } = setMPA();



```






------------------------------------------------------------------
Q2.1 为什么要有 cleanWebpackPlugin/ 它有什么作用 + 如何使用

A: <br/>
1. 自动清理: 自动清理构建目录，避免手动维护的错误 + 提高构建效率

2. 一致性: 确保每次构建时，输出目录都是干净的，避免遗留文件

3. 使用方法:

3.1 安装插件 <br/>
```bash
yarn add clean-webpack-plugin -D
```

3.2 在 webpack.config.js 中配置

```javascript
const { CleanWebpackPlugin } = require('clean-webpack-plugin');

module.exports = {
  // ... 其他配置
  plugins: [
    new CleanWebpackPlugin()
  ]
};
```


------------------------------------------------------------------
Q3.1 如何自动补齐 CSS3 前缀

A: <br/>

1. 安装 postcss-loader +  autoprefixer插件

```bash
yarn add postcss-loader autoprefixer -D
```

2. 在项目根目录下创建 postcss.config.js 文件

```javascript
module.exports = {
  plugins: [ require('autoprefixer') ]
};
```   

3. 在 webpack.config.js 中配置

```javascript
module.exports = {
  module: {
    rules: [
      { 
        test: /\.css$/, 
        use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader'] 
      }
    ]
  }
};
```


------------------------------------------------------------------
Q4.1 如何把 px 转换为 rem

A: <br/>

1. 安装 postcss-loader + px2rem-loader插件

```bash
yarn add postcss-loader px2rem-loader -D
```

2. 在项目根目录下创建 postcss.config.js 文件

```javascript
module.exports = {
  plugins: [ require('px2rem-loader')({ remUnit: 75, remPrecision: 8 }) ]
};
```

3. 在 webpack.config.js 中配置

```javascript
module.exports = {
  // ... 其他配置
  module: { 
    rules: [ 
      { 
        test: /\.scss$/, 
        use: [
          MiniCssExtractPlugin.loader, 
          'css-loader', 
          'sass-loader',
          'postcss-loader',
          'px2rem-loader'
        ] 
      } 
    ] 
  }
};
```


------------------------------------------------------------------
Q4.2 px/ rem/ vw 单位转换的原理是什么

A: <br/>

需要单独写一篇QA, 暂略


------------------------------------------------------------------
Q5.1 为什么需要引入 资源内联功能/ 有什么作用

A: <br/>

1. 在代码层面
 - 便于加载 页⾯框架的需要的 初始化脚本
 - 上报相关打点
 - 关键CSS的内联可以避免页面闪烁，提高用户体验

2. 在性能层面
  - 减少HTTP请求：内联 图片/字体资源 可以减少浏览器需要发起的HTTP请求数，提高页面加载速度
  - 需要注意 权衡文件大小增加 和 缓存策略的影响。过度使用可能导致HTML文件过大，反而影响加载速度


------------------------------------------------------------------
Q5.2 如何实现 在 HTML 中内联 HTML/JS/CSS 资源

A: <br/>

1. raw-loader + HTML内联 其他HTML资源（如 公共的meta.html）

```html
<script>${require(' raw-loader!babel-loader!. /meta.html')}</script>
```

2. raw-loader + HTML内联 公共JS

```html
<script>${require('raw-loader!babel-loader!../node_modules/lib-flexible')}</script>
```

3. HTML内联 CSS
  - 方法1: 借助 style-loader
  - 方法2: 通过 html-inline-css-webpack-plugin

```js
// 方法1: style-loader
module.exports = {
  module: {
    rules: [
      {
        test: /\.scss$/, 
        use: [
          {
            loader: 'style-loader', 
            options: {
              insertAt: 'top', // 样式插入到 <head>
              singleton: true, //将所有的style标签合并成一个 
            }
          }, 
          "css-loader", 
          "sass-loader"
        ],
      },
    ]
  },
};
```